注释 --- #, #后的文本为注释

python中一切皆对象
	bool类：
		实例True, False

数字
	整数，不区分long和int，只有long.
		进制0xa(十六)、0o10(八)、0b10(二进制)
		bool, True, False

	浮点数: i386才引入浮点运算器
		1.2, 3.1415, -0.12, 1.46e9等价1.46*10**9
		渲染：浮点型cpu
		并行计算(gpu, 浮点型cpu)

	复数： a + bj 实数+虚数
		1+2j

字符串
	使用单双引号引用的字符的序列
	单双三引号，可以跨行、可以自由使用单双引号
	r或R前缀，所有字符不转义

转义序列
	\\ \本身,  
	\t  tab,  
	\r  enter,  
	\n  新一行,  
	\'  '本身, 
	\" "本身

缩进
	表示层次关系
	约定4个空格缩进

续行符
	行尾使用\
	使用各种括号，认为括号内是一个整体，内部跨行不用\

标识符
	字母、数字、下划线，不能数字开头
	不能是关键字: def, class
	大小写敏感

	人为约定
		变量不使用中文
		变量不使用歧义单词： class_
		变量不使用_开头的标识符

常量
	一旦定义就不能改变值的标识符
	python无法定义常量

字面常量
	在内存中有固定位置的量：12, "abc", '234.03e-9'

变量
	标识符赋值后，可以改变值的标识符


python语言类型
	动态编译：不用申明类型，可以任意修改类型。运行时才抛错。
	静态编译：申明整型或字符串，申明后不能修改类型。编译时检查。

	不同类型是否可以运算
		强类型：自己决定。不可以运算。
		弱类型：隐式转换，可以运算。

	动态编译中的强类型

运算符
	+ - * / % **

	3.x
		自然除/ 结果是浮点数放
		整除//
	2.x
		/和//都是整数
		>>> 1/5
		0
		>>> 1//5
		0

位运算符
	& 按位与
	| 按位或
	~ 按位取反
		所有正整数的按位取反是其本身+1的负数
		所有负整数的按位取反是其本身+1的绝对值
		零的按位取反是 -1
	^ 按位异或 若参加运算的两个二进制位值相同则为0，否则为1
	<< 左移
	>> 右移

	常用方式：乘除2的位数，32 // 4相当于 32 >> 2，python没有必要，解释器已经优化。
	12
	0xc 16进制 --> 13
	0o14 8进制 --> 8+6
	0b1100 2进制 --> 8421: 8+4=12

	~12：按取反
		1、求二进制， bin()：十进制转换二进制，在前面补0到8位(内存最小存储单位是1Bytes,即8个2进制)。
			0b1100
			0000 1100

		3、按位取反
			1111 0011

			计算机内存中存储数字是补码：只有负数首位为1
			取反结果就是补码

		4、对补码求负数。-1剩余位取反 
			1111 0011 -1 =  1111 0010
			1111 0010 取反 1000 1101
			- 8421：-13

		求补码
			正数的补码和原码相同；负数的补码为符号位不变，剩余位取反再加1.
			
	5-1
		5补码：0000 0101
		-1补码：1111 1111
		0000 0101 + 1111 1111 = 0000 0100 -> 4

	10^9
		0000 1010 ^ 0000 1001 = 0000 0011 -> 3

	10^-9
		0000 1010 ^ 1111 0111 = 1111 1101 对负数补码求负数 --> 1000 0011 --> -3

运算符
	返回bool值

	比较
		==
		!=
		>
		<
		>=
		<=

		1 < '1'
		1 == '1'
		注意：!=, ==可以实现不同类型比较, 比较时将两边统一类型。

	逻辑
		and 
		or
		not

		短路运算
			true or x -> true
			false and x -> false

	赋值
		a = min(3, 5)
		+= -= *= /= %=
		x = y = z = 10  

		注意：支持连等，但是不要用，引用类型时出大事。
			python中没有++, --

	成员：
		in
		not in

	身份:
		is
		not is

表达式
	由数字、符号、括号、变量等组合
		算数表达式
		逻辑表达式
		赋值表达式
			动态语言，赋值即申明类型，后重新赋值即修改类型。
			静态语言，申明类型，后不能修改。


内存管理
	编程中一般不关心变量存亡，不关心内存管理
	python使用引用计数记录所有变量的引用数
		变量引用数变为0，它就可以被 垃圾回收GC
		计数增加：赋值给其它变量就增加引用计数，x = 3; y = x
		计数减少：
			函数运行结束时，局部变量就会被自动销毁，对象引用计数减少。
			变量被赋值给其它对象。x = 3; y = x; x = 4

	有关性能的时候，就需要考虑变量的引用问题，但是该释放内存，还是尽量不释放内存，看需求。

	考虑GC回收时机：垃圾回收、内存整理
	虚拟机调优：GC参数调优，生产环境中，不能随便调GC.

程序控制
	顺序
	分支
	循环

单分支
	if condition:
		if-true

	condition必须是bool类型, 隐式转换bool(condition)

真值表
	false
		"" 
		0
		()
		[]
		{}
		None
	true
		"string"
		非0

	引用对象，没有赋值。即None

多分支
	if..elif..else语句

	if cond1：
		if-true
	elif cond2:
		if-true
	...
	elif condN:
		if-true
	else:
		all-false

双分支
	if condition:
		if-true
	else:
		if-false

分支嵌套
	嵌套结构，可以是分支、循环的嵌套
	可以互相嵌套多层

	嵌套多层时，可以抽象成函数

input函数
	接收用户从控制输入的数据，返回字符串。
	num = input()
	num = input('type your number: ')

练习：
	给定一个不超过5位的正整数，判断其有几位。例如123

	折半思想：
		条件是>
			内部有2种可能时，使用>和<随意 

			内部大于2种可能时，使用与条件相反的<

	val = input('>>> ')
	val = int(val)

	if val >= 1000: #条件是>
		# 内部只有4, 5两种可能
		if val >= 10000:
			print(5)
		else:
			print(4)
	else: #条件是<
		#内部有1，2，3三种可能,用 >
		if val >= 100:
			print(3)
		elif val >= 10:
			print(2)
		else:
			print(1)

