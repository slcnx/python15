queue

特性：练熟方法，在体会

数据结构
	一、数值:
		int: 长整型，没有上限。受限于进程(寻址的可用的)内存。(虚拟内存)2^32 - (只读) = 可用
		float: 双精度.小数点浮动. 注意：大多数并不能完全精确的表示一个小数。判断时只能使用 >, <, 不要使用==。
		complex：复数。使用少。例如：实数和虚数组成：3+4.2J
		bool：int的子类，继承int. int的具有的特征bool也具有。True 对应1. False对应0. 可以和整数直接运算。
			1+True
			1+True+2.0

		数值类型转型：
			int(x) 只拿整数部分。3 // 2
			float(x)
			complex(x), complex(x,y)
			bool(x)

		类型判断
			type(obj) 返回type类中的某个类
				type(obj) == str, 返回布尔值
				isinstance(obj, class_or_tuple), 返回布尔值

				类: 抽象概念.         人类
				实例: 具体存在的实体. 人

				isinstance(6, str)
				isinstance(6, (str, int, bool))

		数值处理函数
			round() .四舍 .6入 .5取偶(最近的偶数)。
			min() 接序列
			max() 接序列
			pow(x,y)等于x**y

			import math
				取整：
					math.floor() 向下
					math.ceil()  向上
					math.sqrt()  开平方根
					math.pi      π
					math.e       自如常数

			进制函数，返回字符串
				bin() 二进制
				oct() 八进制
				hex() 十六进制

	二、序列：sequence
		1）字符串
		2）列表: 由若干个元素(数值、字符、对象、列表)有序的组成
			元素可变的线性数据结构
				元素是对象：是指针。复制的是指针。修改复制后的结果会影响原列表。
				元素是数值、字符：是具体的数。复制的具体的数。修改复制后的结果不会影响原列表。
			符号：[]

			list、链表、queue、stack差异
				list：内存中排序整齐，由前一个知道下一个在哪。固定偏移。
				链表：内存中零散的放着，不能使用索引。
				queue: 可列表或链表实现，队伍特点：先进先出(放行)或后进先出(死胡同)。
				stack: 后进先出(死胡同)
				图形理解区别，然后用好它。

			1）、查帮助：
				1）开始菜单--> python3.x --> python manual --> 官方帮助文档 --> 搜索关键字

				2）Ipython中
					help(keyword)
						keyword: 变量名、对象名、类名、函数名、方法名，不是名时，会隐式转换成类名。

				3）Google

			2）、获取帮助：help(list)
				list() -> new empty list
				list(iterable) -> new list initialized from iterable's items
					iterable: 可迭代对象(range(), 顺序的也是可迭代的: 列表)

			3）、生成列表：
				lists = []
				lists = [1, 2, 'a', None, [1, 2, 'a', None]] #放不同的类型
					注意：lists列表中有5个元素，最后一个列表是一个整体元素。此处存放的是一个指针并非是列表，指针指向一个列表。

				lists = list()
				lists = list(range(5))

				lists = [i for i in range(5)]

			4）、索引访问元素：
				约定索引：
					左(下)边界 <---------------> 右(上)边界
					0 1 2 ........................ -3 -2 -1

				lists[index]
				索引超界(使用索引不能定位到列表中的元素)，引发异常IndexError.
				索引指向一段内存空间的起始地址。

				list[5] 是序号的第5+1个元素。
					序号：1, 2, 3, 4, 5 ...
					索引：0, 1, 2, 3, 4 ...

			1、列表操作：
				1）、查询
					1）单个元素的索引 index()
						index(value, [start[, stop]])
						在[start,stop)索引区间中，查找首个value时，返回value的索引(始终是正索引)。找不到值时，返回ValueError。

						>>> lst = [1, 2, 3, 2, 2, 5]
						>>> lst.index(2)
						1
						>>> lst.index(2,1)
						1
						>>> lst.index(2,2)
						3
						>>> lst.index(2,-1)
						Traceback (most recent call last):
						  File "<stdin>", line 1, in <module>
						ValueError: 2 is not in list
						>>> lst.index(2,-1,-4)
						Traceback (most recent call last):
						  File "<stdin>", line 1, in <module>
						ValueError: 2 is not in list
						>>> lst.index(2,-4,-1)
						3
					2）单个元素的次数 count()
						count(value)
						列表中值的个数
						>>> lst.count(2)
						3

					时间复杂度：
						O(1) 只需看一个元素，就能返回结果。
						O(n) 需要遍历所有元素，才能返回结果。n（列表元素）增加时，时间会一直向上增加。
						O(logn)
						O(n^2)
						
						注意：自己写的代码的效率问题。
					
					3）所有元素的个数 len()
						len(sequence)
						读的内存结构中固定的位置，专用于记录列表长度，是列表的元数据。
						自己设计数据结构，也需要将反复使用的数据放在一个固定的位置。

						>>> len('123')
						3
						>>> len(lists)
						5

				2）、修改：
					注意：列表长度不变。
					1）单个元素修改
						list[index]=value

						>>> lst = [1, 2, 3, 2, 2, 5, 2]	
						#最后一个元素
						>>> lst[len(lst)-1] = 6
						>>> lst
						[1, 2, 3, 2, 2, 5, 6]

					2）多个元素修改
						reversed() -> None

							列表的元素反转，返回None。除了中间那个不动(奇数个)，都要反转。
							就地修改

							>>> lst1
							[12, 13, 7, 1, 3, 2, 2, 5, 6, 10]
							>>> lst1.reverse()
							>>> lst1
							[10, 6, 5, 2, 2, 3, 1, 7, 13, 12]

						sort(key=None, reverse=False) -> None
							key=None, reverse=False： 表示缺省值，默认值。不用给：默认升序，由小到大。
							列表的元素排序
							就地修改
							>>> lst1
							[10, 6, 5, 2, 2, 3, 1, 7, 13, 12]
							>>> lst1.sort()
							>>> lst1
							[1, 2, 2, 3, 5, 6, 7, 10, 12, 13]

							注意：对存在默认值的函数，第一个参数必须是默认值。进行传参时，只对非默认值的参数赋值时，应该写上参数名等于值。否则会将实参与行参一一对应，这样就给行参第一个赋值了。
							>>> lst1.sort(True)
							Traceback (most recent call last):
							  File "<stdin>", line 1, in <module>
							TypeError: must use keyword argument for key function

							>>> lst1.sort(reverse=True)
							>>> lst1
							[13, 12, 10, 7, 6, 5, 3, 2, 2, 1]

							注意：少用排序，需要输出有排序的序列的时候，在用sort.

							注意：相同类型排序没有问题，不同类型排序。使用函数: lst.sort(key=function)
							>>> lst1
							[13, 12, 10, 7, 6, 5, 3, 2, 2, 1]
							>>> lst1.append('a')
							>>> lst1
							[13, 12, 10, 7, 6, 5, 3, 2, 2, 1, 'a']
							>>> lst1.sort()
							Traceback (most recent call last):
							  File "<stdin>", line 1, in <module>
							TypeError: '<' not supported between instances of 'str' and 'int'
							#混合排序
							>>> lst1.sort(key=str) #使用str函数。相当于str()函数操作每个元素的结果进行排序。函数里面的参数是函数，是高阶函数。
							>>> lst1
							[1, 10, 12, 13, 2, 2, 3, 5, 6, 7, 'a']

							>>> lst1.sort(key=str, reverse=True) #看出降序效果。
							>>> lst1
							['a', 7, 6, 5, 3, 2, 2, 13, 12, 10, 1]

				3）、增加、插入元素：
					注意：列表长度改变
					append(object) -> None
						
						表示尾部追加一个元素返回空值(None)，返回空值(None)则表示就地修改(修改对象本身)。
						时间复杂度O(1)

						查看返回值为空值(None).
							>>> lst
							[1, 2, 3, 2, 2, 5, 6]
							>>> a = lst.append(10)
							>>> type(a)
							<class 'NoneType'>
							>>> a
							>>> print(a)
							None

					insert(index, object) -> None

						表示插队，会影响别人，所有元素都会向后挪(内存中所有元素会挪动)，效率极低。
							>>> lists
							[11, 0, 1, 2, 3, 4]
							>>> lists.insert(-1,11)
							>>> lists
							[11, 0, 1, 2, 3, 11, 4]
							>>> lists.insert(-2,12)
							>>> lists
							[11, 0, 1, 2, 3, 12, 11, 4]
						index超上界，上界追加。
						index超下界，下界追加。
							>>> lst
							[1, 2, 3, 2, 2, 5, 6, 10]
							>>> lst.insert(100,7) #调用append就可以了。
							>>> lst
							[1, 2, 3, 2, 2, 5, 6, 10, 7]

							>>> lst.insert(-100,7) #所有元素都会挪动，效率低。
							>>> lst
							[7, 1, 2, 3, 2, 2, 5, 6, 10, 7]

					*
						>>> lst1
						[]
						>>> lst1*5
						[]
						>>> lst1 = [1]
						>>> lst1*5 #有输出时，都不会变
						[1, 1, 1, 1, 1]
						>>> lst1 = lst1*5

					+ 
						>>> lst1 = [11, 12, 13]
						>>> lst
						[7, 1, 2, 3, 2, 2, 5, 6, 10, 7]
						>>> lst + lst1 #有输出时，都不会变
						[7, 1, 2, 3, 2, 2, 5, 6, 10, 7, 11, 12, 13]

					extend(iterable) -> None
						iterable: 可迭代对象(range(), 顺序的也是可迭代的: 列表)
						返回空值(None)则表示就地修改(修改对象本身)。
						>>> lst1 = [11, 12, 13]
						>>> lst
						[7, 1, 2, 3, 2, 2, 5, 6, 10, 7]
						>>> lst1.extend(lst1) #就地修改
						>>> lst1
						[11, 12, 13, 7, 1, 2, 3, 2, 2, 5, 6, 10, 7]

				4）、删除
					clear() -> None
						
						清空所有元素，剩下空列表。
						注意：很多对象释放(大规模的数据集清除后或做过多的clear)，会引起垃圾回收。这个时候你正在忙，它在垃圾回收。你的内存会被它调整一次。这个时候就带来效率问题。
						可能需要new一个。
						>>> lst
						[7, 1, 2, 3, 2, 2, 5, 6, 10, 7, 11, 12, 13]
						>>> lst.clear()
						>>> lst # 注意，剩下空列表
						[]

						扩展：
							clear() 和 = []区别
								list.clear() 内存结构保留，只清元素。
								list = []   内存结构清除。

					remove(value) -> None

						从左而右查找第一个匹配的value值，移除之。
						就地修改
						效率：中间操作会引起位置向前挪动，效率变低。	
						
						>>> lst1
						[11, 12, 13, 7, 1, 2, 3, 2, 2, 5, 6, 10, 7]
						>>> lst1.remove(2)
						>>> lst1
						[11, 12, 13, 7, 1, 3, 2, 2, 5, 6, 10, 7]

					pop([index]) -> item
						注意：返回不是None，也是就地修改。
						pop() 移除最后一个元素，返回此元素。 O(1)
						pop(index) 移除由index指定的元素，返回此元素。

							>>> lst1
							[11, 12, 13, 7, 1, 3, 2, 2, 5, 6, 10, 7]
							>>> lst1.pop()
							7
							>>> lst1
							[11, 12, 13, 7, 1, 3, 2, 2, 5, 6, 10]

							注意：当index为0时，列表足够长时，内存中整个列表的元素都会向前挪。效率极低！
								index不是-1时，效率都会有影响。
							>>> lst1
							[11, 12, 13, 7, 1, 3, 2, 2, 5, 6, 10]
							>>> lst1.pop(0)
							11
							>>> lst1
							[12, 13, 7, 1, 3, 2, 2, 5, 6, 10]


				5）、成员运算符: 是否是集合内的整个元素，返回布尔型。
					30 in [[30,20]] False
					[3, 4] in [1, 2, [3, 4]] True
					for x in [1, 2, 3, 4] 循环

					布尔型可以放在if语句中
						if 30 not in [[30, 20]]:
							pass #pass是占位语句，什么都不做。不pass，语法不对。怎么处理不知道。回过头来修改。

			2、列表复制

				小知识：
					== 值比较
					is 比内存地址，id()值比较。

					>>> lst0 = list(range(4))
					>>> id(lst0) #id() 获取标识，内存地址。
					45913072
					>>> hash(lst0) #列表不可hash
					Traceback (most recent call last):
					  File "<stdin>", line 1, in <module>
					TypeError: unhashable type: 'list'
					>>> hash(id(lst0)) #整型hash是本身
					45913072
					>>> lst1 = list(range(4))
					>>> id(lst1)
					45936688
					>>> lst0 == lst1  #== 比较内容
					True	
					>>> lst0 is lst1  #is 比较内容和内存位置. not is
					False
					
				注意：= 赋值，lst1指向的内存空间和lst0内存空间相同。不会新开辟内存空间。内存地址也相同。
					变量名：对内存中一段空间起名。 
					>>> lst1 = lst0
					>>> id(lst1) #此处内存地址是上面lst0内存地址，相同的。
					45913072

					lst1[2] = 10
					>>> lst1
					[0, 1, 10, 3]
					>>> lst0 #注意，修改lst1也把lst0修改了。
					[0, 1, 10, 3]


				copy() -> list
					
					拷贝出一个新列表。
					>>> lst0 = list(range(4))
					>>> lst0
					[0, 1, 2, 3]
					>>> lst0.copy()
					[0, 1, 2, 3]
					>>> lst5 = lst0.copy() #浅拷贝
					>>> lst5
					[0, 1, 2, 3]
					>>> lst0 == lst5
					True
					>>> id(lst0)
					45827056
					>>> id(lst5)
					45905040
					>>> lst5 is lst0
					False

					注意：列表元素是复杂类型(列表、对象...)，拷贝的是复杂类型的地址。
					>>> lst0 = [1, [2, 3, 4], 5]
					>>> lst5 = lst0.copy()
					>>> lst0
					[1, [2, 3, 4], 5]
					>>> lst5
					[1, [2, 3, 4], 5]
					>>> lst5 == lst0
					True
					>>> lst5 is lst0
					False

					#对于非复杂类型单个元素拷贝的是本身。
					>>> lst5[2] = 10
					>>> lst5
					[1, [2, 3, 4], 10]
					>>> lst0
					[1, [2, 3, 4], 5]
					>>>
					#对于复杂类型(列表、对象...)，拷贝的是地址
					>>> lst5[2] = 5
					>>> lst5
					[1, [2, 3, 4], 5]
					>>> lst0
					[1, [2, 3, 4], 5]
					
						#一个列表复杂类型中的元素改变，另一个列表复杂类型中的元素也改变了。
						>>> lst5[1][1] = 20
						>>> lst5 == lst0
						True
						>>> lst5
						[1, [2, 20, 4], 5]
						>>> lst0
						[1, [2, 20, 4], 5]


				扩展：不仅仅是复制，追加一个复杂类型也是引用的追加
					>>> row = []
					>>> lists = [2]
					>>> lists.append(row)
					>>> lists
					[2, []]
					>>> row.append('abc')
					>>> lists
					[2, ['abc']]


				扩展：深拷贝
					和以上浅拷贝的区别在于：拷贝元素是复杂类型时，拷贝的是整个元素，拷贝源和拷贝出的内容复杂类型是指向不同位置。浅拷贝只拷贝引用，拷贝源和拷贝出的内容复杂类型是指向相同位置。
					>>> import copy
					>>> lst0 = [1, [2, 3, 4], 5]
					>>> lst5 = copy.deepcopy(lst0) #深拷贝
					>>> lst5[1][1] = 20
					>>> lst5
					[1, [2, 20, 4], 5]
					>>> lst0
					[1, [2, 3, 4], 5]
					一般情况下，只用浅拷贝就可以了。

				赋值和copy()区别
					赋值：内存地址相同
					copy() 复杂类型引用地址相同

				copy() 和copy.deepcopy()区别
					copy() 复杂类型引用地址相同
					copy.deepcopy() 复杂类型引用地址不同，但是内容相同。

			3、随机数
				#依赖此模块
				import random

				1）、随机取区间内的整数
					random.randint(a,b) [a,b]间整数

					>>> import random
					>>> random.randint(0,1)
					0
					>>> random.randint(0,1)
					1
				
				2）、随机取序列中的元素
					random.choice(sequence)
					
					>>> random.choice('abc')
					'b'
					>>> random.choice(['a',1,2])
					2
					>>> random.choice(range(10))
					5	

				3）、随机从range()函数内取单个整数。
					random.randrange()
						
						randrange(stop) -> 从0到stop-1之间取任意单个整数
						randrange(start, stop[, step]) -> [start, stop) 范围取消单个整数


					>>> random.randrange(1)
					0
					>>> random.randrange(2)
					0
					>>> random.randrange(2)
					1

				4) 、将列表元素打乱
					random.shuffle(list) -> None

					>>> lst.sort()
					>>> lst
					[1, 2, 3, 4, 5]
					>>> random.shuffle(lst) #洗列表
					>>> lst
					[1, 5, 2, 4, 3]

					>>> lst.append('a')
					>>> lst
					[1, 5, 2, 4, 3, 'a']
					>>> lst.sort(key=str)
					>>> lst
					[1, 2, 3, 4, 5, 'a']
					>>> random.shuffle(lst)  #洗列表
					>>> lst
					['a', 5, 1, 2, 3, 4]
					>>>

			列表练习
				1、100以内所有素数，一个数能被素数整除就是合数。将算过的质数保留下来。
					合数：2-(本身-1)是否能被整除
					合数：能被素数整除
				2、求杨辉三角
					1）
					2）加0
					3）
						开辟列表空间：列表解析式、循环迭代
						能不能少算一半数字
						
		3）tuple

	三、键值对
		集合: set （老师叫集）
		字典: dict




