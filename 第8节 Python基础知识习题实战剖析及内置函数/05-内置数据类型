queue

特性：练熟方法，在体会

数据结构
	数值:
		int: 长整型，没有上限。受限于进程(寻址的可用的)内存。(虚拟内存)2^32 - (只读) = 可用
		float: 双精度.小数点浮动. 注意：大多数并不能完全精确的表示一个小数。判断时只能使用 >, <, 不要使用==。
		complex：复数。使用少。例如：实数和虚数组成：3+4.2J
		bool：int的子类，继承int. int的具有的特征bool也具有。True 对应1. False对应0. 可以和整数直接运算。
			1+True
			1+True+2.0

		数值类型转型：
			int(x) 只拿整数部分。3 // 2
			float(x)
			complex(x), complex(x,y)
			bool(x)

		类型判断
			type(obj) 返回type类中的某个类
				type(obj) == str, 返回布尔值
				isinstance(obj, class_or_tuple), 返回布尔值

				类: 抽象概念.         人类
				实例: 具体存在的实体. 人

				isinstance(6, str)
				isinstance(6, (str, int, bool))

		数值处理函数
			round() .四舍 .6入 .5取偶(最近的偶数)。
			min() 接序列
			max() 接序列
			pow(x,y)等于x**y

			import math
				取整：
					math.floor() 向下
					math.ceil()  向上
					math.sqrt()  开平方根
					math.pi      π
					math.e       自如常数

			进制函数，返回字符串
				bin() 二进制
				oct() 八进制
				hex() 十六进制

	序列：sequence
		1）字符串
		2）列表: 由若干个元素(数值、字符、对象、列表)有序的组成
			元素可变的线性数据结构
				元素是对象：是指针。复制的是指针。修改复制后的结果会影响原列表。
				元素是数值、字符：是具体的数。复制的具体的数。修改复制后的结果不会影响原列表。
			符号：[]

			list、链表、queue、stack差异
				list：内存中排序整齐，由前一个知道下一个在哪。固定偏移。
				链表：内存中零散的放着，不能使用索引。
				queue: 可列表或链表实现，队伍特点：先进先出(放行)或后进先出(死胡同)。
				stack: 后进先出(死胡同)
				图形理解区别，然后用好它。

			查帮助：
				1）开始菜单--> python3.x --> python manual --> 官方帮助文档 --> 搜索关键字

				2）Ipython中
					help(keyword)
						keyword: 变量名、对象名、类名、函数名、方法名，不是名时，会隐式转换成类名。

				3）Google

			获取帮助：help(list)
				list() -> new empty list
				list(iterable) -> new list initialized from iterable's items
					iterable: 可迭代对象(range(), 顺序的也是可迭代的: 列表)

			生成列表：
				lists = []
				lists = [1, 2, 'a', None, [1, 2, 'a', None]] #放不同的类型
					注意：lists列表中有5个元素，最后一个列表是一个整体元素。此处存放的是一个指针并非是列表，指针指向一个列表。

				lists = list()
				lists = list(range(5))

				lists = [i for i in range(5)]

			索引访问：
				约定索引：
					左(下)边界 <---------------> 右(上)边界
					0 1 2 ........................ -3 -2 -1

				lists[index]
				索引超界(使用索引不能定位到列表中的元素)，引发异常IndexError.
				索引指向一段内存空间的起始地址。

				list[5] 是序号的第5+1个元素。
					序号：1, 2, 3, 4, 5 ...
					索引：0, 1, 2, 3, 4 ...

			列表操作：
				查询
					单个元素的索引 index()
						index(value, [start[, stop]])
						在[start,stop)索引区间中，查找首个value时，返回value的索引(始终是正索引)。找不到值时，返回ValueError。

						>>> lst = [1, 2, 3, 2, 2, 5]
						>>> lst.index(2)
						1
						>>> lst.index(2,1)
						1
						>>> lst.index(2,2)
						3
						>>> lst.index(2,-1)
						Traceback (most recent call last):
						  File "<stdin>", line 1, in <module>
						ValueError: 2 is not in list
						>>> lst.index(2,-1,-4)
						Traceback (most recent call last):
						  File "<stdin>", line 1, in <module>
						ValueError: 2 is not in list
						>>> lst.index(2,-4,-1)
						3
					单个元素的次数 count()
						count(value)
						列表中值的个数
						>>> lst.count(2)
						3

					时间复杂度：
						O(1) 只需看一个元素，就能返回结果。
						O(n) 需要遍历所有元素，才能返回结果。n（列表元素）增加时，时间会一直向上增加。
						O(logn)
						O(n^2)
						
						注意：自己写的代码的效率问题。
					
					所有元素的个数 len()
						len(sequence)
						读的内存结构中固定的位置，专用于记录列表长度，是列表的元数据。
						自己设计数据结构，也需要将反复使用的数据放在一个固定的位置。

						>>> len('123')
						3
						>>> len(lists)
						5

				修改：
					注意：列表长度不变。
					单个元素修改
						list[index]=value

					>>> lst = [1, 2, 3, 2, 2, 5, 2]	
					#最后一个元素
					>>> lst[len(lst)-1] = 6
					>>> lst
					[1, 2, 3, 2, 2, 5, 6]

				增加、插入元素：
					注意：列表长度改变
					append(object) -> None
						
						表示尾部追加一个元素返回空值(None)，返回空值(None)则表示就地修改(修改对象本身)。
						时间复杂度O(1)

						查看返回值为空值(None).
							>>> lst
							[1, 2, 3, 2, 2, 5, 6]
							>>> a = lst.append(10)
							>>> type(a)
							<class 'NoneType'>
							>>> a
							>>> print(a)
							None

					insert(index, object) -> None

						表示插队，会影响别人，所有元素都会向后挪(内存中所有元素会挪动)，效率极低。
							>>> lists
							[11, 0, 1, 2, 3, 4]
							>>> lists.insert(-1,11)
							>>> lists
							[11, 0, 1, 2, 3, 11, 4]
							>>> lists.insert(-2,12)
							>>> lists
							[11, 0, 1, 2, 3, 12, 11, 4]
						index超上界，上界追加。
						index超下界，下界追加。
							>>> lst
							[1, 2, 3, 2, 2, 5, 6, 10]
							>>> lst.insert(100,7) #调用append就可以了。
							>>> lst
							[1, 2, 3, 2, 2, 5, 6, 10, 7]

							>>> lst.insert(-100,7) #所有元素都会挪动，效率低。
							>>> lst
							[7, 1, 2, 3, 2, 2, 5, 6, 10, 7]

					*
						>>> lst1
						[]
						>>> lst1*5
						[]
						>>> lst1 = [1]
						>>> lst1*5 #有输出时，都不会变
						[1, 1, 1, 1, 1]
						>>> lst1 = lst1*5

					+ 
						>>> lst1 = [11, 12, 13]
						>>> lst
						[7, 1, 2, 3, 2, 2, 5, 6, 10, 7]
						>>> lst + lst1 #有输出时，都不会变
						[7, 1, 2, 3, 2, 2, 5, 6, 10, 7, 11, 12, 13]

					extend(iterable) -> None
						iterable: 可迭代对象(range(), 顺序的也是可迭代的: 列表)
						返回空值(None)则表示就地修改(修改对象本身)。
						>>> lst1 = [11, 12, 13]
						>>> lst
						[7, 1, 2, 3, 2, 2, 5, 6, 10, 7]
						>>> lst1.extend(lst1) #就地修改
						>>> lst1
						[11, 12, 13, 7, 1, 2, 3, 2, 2, 5, 6, 10, 7]

				删除
					clear() -> None
						
						清空所有元素，剩下空列表。

						>>> lst
						[7, 1, 2, 3, 2, 2, 5, 6, 10, 7, 11, 12, 13]
						>>> lst.clear()
						>>> lst # 注意，剩下空列表
						[]

					remove(value) -> None

						从左而右查找第一个匹配的value值，移除之。
						就地修改
						效率：中间操作会引起位置挪动，效率变低。	
						
						>>> lst1
						[11, 12, 13, 7, 1, 2, 3, 2, 2, 5, 6, 10, 7]
						>>> lst1.remove(2)
						>>> lst1
						[11, 12, 13, 7, 1, 3, 2, 2, 5, 6, 10, 7]

					pop([index]) -> item
						注意：返回不是None，也是就地修改。
						pop() 移除最后一个元素，返回此元素。 O(1)
						pop(index) 移除由index指定的元素，返回此元素。


							>>> lst1
							[11, 12, 13, 7, 1, 3, 2, 2, 5, 6, 10, 7]
							>>> lst1.pop()
							7
							>>> lst1
							[11, 12, 13, 7, 1, 3, 2, 2, 5, 6, 10]

							注意：当index为0时，列表足够长时，内存中整个列表的元素都会向前挪。效率极低！
								index不是-1时，效率都会有影响。
							>>> lst1
							[11, 12, 13, 7, 1, 3, 2, 2, 5, 6, 10]
							>>> lst1.pop(0)
							11
							>>> lst1
							[12, 13, 7, 1, 3, 2, 2, 5, 6, 10]


		3）tuple

	键值对
		集合: set （老师叫集）
		字典: dict




