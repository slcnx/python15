queue

特性：练熟方法，在体会

数据结构
	一、数值:
		int: 长整型，没有上限。受限于进程(寻址的可用的)内存。(虚拟内存)2^32 - (只读) = 可用
		float: 双精度.小数点浮动. 注意：大多数并不能完全精确的表示一个小数。判断时只能使用 >, <, 不要使用==。
		complex：复数。使用少。例如：实数和虚数组成：3+4.2J
		bool：int的子类，继承int. int的具有的特征bool也具有。True 对应1. False对应0. 可以和整数直接运算。
			1+True
			1+True+2.0

		数值类型转型：
			int(x) 只拿整数部分。3 // 2
			float(x)
			complex(x), complex(x,y)
			bool(x)

		类型判断
			type(obj) 返回type类中的某个类
				type(obj) == str, 返回布尔值
				isinstance(obj, class_or_tuple), 返回布尔值

				类: 抽象概念.         人类
				实例: 具体存在的实体. 人

				isinstance(6, str)
				isinstance(6, (str, int, bool))

		数值处理函数
			round() .四舍 .6入 .5取偶(最近的偶数)。
			min() 接序列
			max() 接序列
			pow(x,y)等于x**y

			import math
				取整：
					math.floor() 向下
					math.ceil()  向上
					math.sqrt()  开平方根
					math.pi      π
					math.e       自如常数

			进制函数，返回字符串
				bin() 二进制
				oct() 八进制
				hex() 十六进制

	二、序列：sequence
		学习路径: list --> [tuple --> 字符串 --> bytes] --> bytearray

		1）字符串
			不可变的 有序的 字符串类型组成的 序列

			由单、双和三引号引住的 N个“字符串”的有序组合
			字符串是不可变对象
			python3 字符串是Unicode类型, UTF-8。(后面字符串的编码、解码；默认都是unicode, utf-8) 比较适合在网络中传输

			第二个不可变对象(元组、字符串)
				In [22]: a = 'ab' + 'c'

				In [23]: a
				Out[23]: 'abc'

				In [24]: id(a) #内存位置
				Out[24]: 30309632

				In [25]: a = 'ab' + 'c' + "d" #修改时

				In [26]: id(a) #内存位置在新位置，不是原地修改。
				Out[26]: 62132928

				#不可变对象
				In [27]: a[1] #有序，即有索引。
				Out[27]: 'b'

				In [28]: a[1] = 'f'
				---------------------------------------------------------------------------
				TypeError                                 Traceback (most recent call last)
				<ipython-input-28-be586423cf45> in <module>()
				----> 1 a[1] = 'f'

				TypeError: 'str' object does not support item assignment

			python字符串，是“字符串”的组合
				In [47]: a[1]
				Out[47]: 'b'

				In [48]: type(a)
				Out[48]: str

				In [49]: type(a[1]) #每个元素还是字符串
				Out[49]: str


			定义
				In [29]: s1 = 'string'

				In [30]: s2 = "string2"

				In [31]: s3 = '''this's a "String" ''' 

				In [32]: s4 = 'hello \n magedu.com'

				In [33]: s5 = r"hello \n magedu.com" 

				In [34]: s6 = 'c:\windows\nt'

				In [35]: s7 = R"c:\windows\nt"

				In [36]: s8 = 'c:\windows\\nt'

				In [37]: sql = """select * from user where name='tom'""" 

				三引号：其中可以直接使用换行，单双引号。
				字符串前加r, R表示字符串中任何字符是原本意义。处理windows目录

			字符串元素访问 -- 下标 
				字符串支持索引访问：有序
					In [58]: sql = """select * from user where name='tom'"""

					In [59]: sql[4]
					Out[59]: 'c' #返回的是字符串，老师叫(字符)
				字符串不可变	
					In [60]: sql[4] = 'o'
					---------------------------------------------------------------------------
					TypeError                                 Traceback (most recent call last)
					<ipython-input-60-fe3590bf222f> in <module>()
					----> 1 sql[4] = 'o'

					TypeError: 'str' object does not support item assignment
				有序的字符序列，for:
					In [61]: for _ in a:
					    ...:     print(_)
					    ...:     print(type(_)) # 返回字符串类型
					    ...:
						a
						<class 'str'>
						b
						<class 'str'>
						c
						<class 'str'>
				字符串也是可迭代对象。iterable: 可迭代对象(range(), 顺序的也是可迭代的: 列表、元组、字符串)
					In [65]: lst = list(a)

					In [66]: lst
					Out[66]: ['a', 'b', 'c']

					In [68]: t = tuple(a)

					In [69]: t
					Out[69]: ('a', 'b', 'c')

			字符串join连接
				+ 连接
					将两个字符串连接，在内存中生成一个新的字符串对象

				"string".join(iterable) -> str
					以string分隔连接可迭代对象的每个元素
					iterable中的元素都是字符串

					In [74]: a
					Out[74]: 'abc'

					In [75]: ','.join(a)
					Out[75]: 'a,b,c'

					In [76]: '     '.join(a)
					Out[76]: 'a     b     c'

					In [77]: '123'.join(a)
					Out[77]: 'a123b123c'				

					#元素是字符串类型
					In [78]: lst = [1, [2, 3], 4]

					In [79]: "::".join(lst)
					---------------------------------------------------------------------------
					TypeError                                 Traceback (most recent call last)
					<ipython-input-79-79d8729d1f3d> in <module>()
					----> 1 "::".join(lst)

					TypeError: sequence item 0: expected str instance, int found

					#元素不能是引用
					In [82]: lst = ['1', ['2', '3'], '4']

					In [83]: "::".join(lst)
					---------------------------------------------------------------------------
					TypeError                                 Traceback (most recent call last)
					<ipython-input-83-79d8729d1f3d> in <module>()
					----> 1 "::".join(lst)

					TypeError: sequence item 1: expected str instance, list found

					##示例
					In [86]: lst = ['1', '2', '3']

					In [87]: print('\"'.join(lst)) #引号间隔 
					1"2"3

					In [88]: print(" ".join(lst))
					1 2 3

					In [89]: print('\n'.join(lst)) #换行符间隔
					1
					2
					3

					In [90]: lst = ['1',['a','b'],'3'] #元素是列表不可行

					In [91]: print(" ".join(lst))
					---------------------------------------------------------------------------
					TypeError                                 Traceback (most recent call last)
					<ipython-input-91-5a7c8b71fc4f> in <module>()
					----> 1 print(" ".join(lst))

					TypeError: sequence item 1: expected str instance, list found

				* 连接，任何有序序列都可以使用乘号
					In [98]: a
					Out[98]: 'abc'

					In [99]: s1 = a #s1的内存地址是a

					In [100]: s1
					Out[100]: 'abc'

					In [101]: s1 = a*4 

					In [102]: a # s1改变，a应该改变。说明此时a*4生成了新的内存地址。也证明了字符串不可变对象。
					Out[102]: 'abc'

					In [103]: s1
					Out[103]: 'abcabcabcabc'

			字符串分割*
				split系： 将字符串按照分隔符分割成    若干字符串，并返回“列表”。
					split(sep=None, maxsplit=-1) -> list of strings
						从左向右找sep
						sep指定分割字符串，默认是至少为1个空白。awk -F[ ]+
						maxsplit指定分割次数，-1表示遍历整个字符串。

						In [104]: s1 = "I'm \ta super student."

						In [113]: s1.split() #注意默认分隔符是多个空白字符
						Out[113]: ["I'm", 'a', 'super', 'student.']

						In [114]: s1.split(' ') #以单个空白切分
						Out[114]: ["I'm", '\ta', 'super', 'student.']

						In [115]: s1.split(' ',2) #整个字符串, 至少有2个' ', 所以切2次返回3段
						Out[115]: ["I'm", '\ta', 'super student.']

						In [116]: s1.split('\t',maxsplit=2) #整个字符串, 只有一个\t时，切n次只有2段。
						Out[116]: ["I'm ", 'a super student.']

						#从左而后，至少有2个s, 但只切一次，剩下的s在右侧
						In [119]: s1.split(maxsplit=1, sep='s')
						Out[119]: ["I'm \ta ", 'uper student.']

					rsplit(sep=None, maxsplit=-1) -> list of strings (reverse split)
						**从右至左找sep，取出列表是正向。
						sep指定分割字符串，默认是至少为1个空白。awk -F[ ]+
						maxsplit指定分割次数，-1表示遍历整个字符串。	

						#从右至左，至少有2个s, 但只切一次，剩下的s在左侧
						In [120]: s1.rsplit(maxsplit=1, sep='s')
						Out[120]: ["I'm \ta super ", 'tudent.']
						
						#取文件名,反着切速度更快
						In [121]: path = '/var/log/messages'

						In [122]: path.rsplit(maxsplit=1, sep='/')
						Out[122]: ['/var/log', 'messages']

						In [123]: path.rsplit(maxsplit=1, sep='/')[-1]
						Out[123]: 'messages'

					splitlines([keepends]) -> list of strings
						按照行来切分字符串
						keepends：是否保留行分隔符
						行分隔符：\n, \r\n, \r等...

						#行分隔符
						In [126]: 'ab c\n\nde fg\rk1\r\n'.splitlines()
						Out[126]: ['ab c', '', 'de fg', 'k1']

						#保留换行
						In [127]: 'ab c\n\nde fg\rk1\r\n'.splitlines(True)
						Out[127]: ['ab c\n', '\n', 'de fg\r', 'k1\r\n']

						In [128]: s1 = '''I'm a super student.
						     ...: Your're a super teacher.'''

						In [129]: s1
						Out[129]: "I'm a super student.\nYour're a super teacher."

						In [130]: s1.splitlines()
						Out[130]: ["I'm a super student.", "Your're a super teacher."]

						In [131]: s1.splitlines(True)
						Out[131]: ["I'm a super student.\n", "Your're a super teacher."]

				partition系*：将字符串按照分隔符分割成 2段，返回这2段和分隔符的三个元素的“元组”。
					partition(sep) -> (head, sep, tail)
						从左而右，遇到分隔符将字符串分割两部分，返回头、分隔符、尾三元组(三个元素的元组)。
						head, tail: 按sep，切一刀，两段，前head, 后tail.
						sep必须指定，不能为空
						没有分隔符，返回头、2个空元素的三元组。

						In [132]: s1 = "I'm a super student."

						In [133]: s1.partition('s') #从左而右(后面s存在)。以sep分成两段，返回头、分隔符、返回尾，组成一个三个元素的元组。
						Out[133]: ("I'm a ", 's', 'uper student.')

						In [134]:  s1.partition('super')
						Out[134]: ("I'm a ", 'super', ' student.') #注意中间的super是一个分隔符。

						#sep不能为空字符串
						In [136]: s1.partition('')
						---------------------------------------------------------------------------
						ValueError                                Traceback (most recent call last)
						<ipython-input-136-6703bd698c63> in <module>()
						----> 1 s1.partition('')

						ValueError: empty separator

						#不存在的分隔符，返回本身和两个空元素
						In [137]: s1.partition('abc')
						Out[137]: ("I'm a super student.", '', '')

					rpartition(sep) -> (head, sep, tail)                 (reverse partition)
						从右而左，遇到分隔符将字符串分割两部分，返回头、分隔符、尾三元组(三个元素的元组)。
						head, tail: 按sep，切一刀，两段，前head, 后tail.
						sep必须指定，不能为空
						没有分隔符，返回头、2个空元素的三元组。

						In [138]: s1.rpartition('abc')
						Out[138]: ('', '', "I'm a super student.")

						In [139]: s1.rpartition('s')
						Out[139]: ("I'm a super ", 's', 'tudent.') #s是分隔符，注意后面的s不存在。前面的s存在。是从右至左的查找sep

						#处理文件名, 不在需要maxsplit。
						In [140]: path = '/var/log/messages'

						In [141]: path.rpartition('/')
						Out[141]: ('/var/log', '/', 'messages')

						In [142]: path.rpartition('/')[-1]
						Out[142]: 'messages'

			字符串大小写
				应用：大小写，做判断的时候用。如何知道别人输入的命令一定是一定顺序的字符。输入ls，怎么知道是LS, Ls, lS, ls?
				upper() 全大写
				lower() 全小写
				swapcase() 交互大小写, 大写的，变小写。小写的变大写。

					In [143]: s1
					Out[143]: "I'm a super student."

					In [144]: s1.upper()
					Out[144]: "I'M A SUPER STUDENT."

					In [145]: s1.lower()
					Out[145]: "i'm a super student."

					In [146]: s1.swapcase()
					Out[146]: "i'M A SUPER STUDENT."

			字符串排版
				字母型文字的排版，中文用的少
				title() -> str
					标题 每个单词的首字母都大写。

					In [147]: s1.title()
					Out[147]: "I'M A Super Student."

				capitalize() -> str
					行起始 最前面那个单词大写。		

					In [148]: s1.capitalize()
					Out[148]: "I'm a super student."

				center(width[, fillchar]) -> str。有格式化了，不常用。
					居中
					width 打印宽度
					fillchar 填充的字符，默认空。

					In [155]: s2 = "abc"

					In [156]: s2.center(50)
					Out[156]: '                       abc                        '

					In [157]: s2.center(50, '#')
					Out[157]: '#######################abc########################'

				zfill(width) -> str 		（zero fill）
					width 打印宽度，居右，左边用0填充

					In [158]: s2.zfill(50)
					Out[158]: '00000000000000000000000000000000000000000000000abc'

				ljust(width[, fillchar]) -> str左对齐
				rjust(width[, fillchar]) -> str右对齐

					In [159]: s2.ljust(50)
					Out[159]: 'abc                                               '

					In [160]: s2.rjust(50)
					Out[160]: '                                               abc'

					In [161]: s2.ljust(50,'#')
					Out[161]: 'abc###############################################'

					In [162]: s2.rjust(50,'#')
					Out[162]: '###############################################abc'

			字符串修改*
				返回一个新的字符串，注意：字符串是不可变对象
				replace(old, new[, count]) -> str
					从左而右 在字符串中找到 old子串 替换为 new子串， 返回新字符串
					count：替换几次，默认替换所有找到的子串。

					In [164]: 'www.magedu.com'.replace('w','p') #不指定count, 将替换字符串中所有匹配到的子串。
					Out[164]: 'ppp.magedu.com'

					In [165]: 'www.magedu.com'.replace('w','p',2) #替换2次
					Out[165]: 'ppw.magedu.com'

					In [166]: 'www.magedu.com'.replace('w','p',3) 
					Out[166]: 'ppp.magedu.com'

					In [167]: 'www.magedu.com'.replace('ww','p',2) #匹配到一个ww, 替换2次，只能替换一个。
					Out[167]: 'pw.magedu.com'

					In [168]: 'www.magedu.com'.replace('www','python',2) #替换域名
					Out[168]: 'python.magedu.com'

				# 应用：去掉两头或单边的非法字符。用户输入5位数，但加了空格。应该去除两边的空格。
				strip([chars]) -> str
					一直去除字符串两端的 单个字符属于字符集chars中的字符，直到字符串两端的单个字符不存在字符集chars中的任意单个字符。
					如果chars没有指定，去除两端所有空白字符\t, \n, \r\n。

					In [170]: s = "\r\n\tHello Python \n  \t"

					In [171]: s.strip()
					Out[171]: 'Hello Python'


					In [173]: s = 'I am very very very sorry  '

					In [174]: s.strip() #去掉两头的空白
					Out[174]: 'I am very very very sorry'

					In [175]: s.strip('r') #两头没有r,不去掉
					Out[175]: 'I am very very very sorry  '

					In [176]: s.strip('r ') #先看两头是空白，给定的有空白，去掉。但两头没有r，不去掉。
					Out[176]: 'I am very very very sorry'

					In [177]: s.strip('r y')#先看两头是空白，给定的有空白，去掉。然后有y，去掉。然后有r去掉。
					Out[177]: 'I am very very very so'

					In [178]: s.strip('r yI')
					Out[178]: 'am very very very so'

					In [179]: s.strip('r yIamso')
					Out[179]: 'very very ve'

				lstrip([chars]) -> str
					从左开始
				
				rstrip([chars]) -> str
					从右开始

					In [180]: s.rstrip('r yIamso')
					Out[180]: 'I am very very ve'

					In [181]: s.lstrip('r yIamso')
					Out[181]: 'very very very sorry  '

			字符串查找*
				注意: 只有-1时, 表示最后一位.
				使用find, 返回-1,则找不到. 使用index, 返回异常, 需要捕获, 不捕获则异常一直到主线程, 程序会崩溃的. 所以老师更倾向于find, rfind.
				find(sub[, start[, end]]) -> int
					在[start,end) 区间内， 从左而右查找子串sub。找到返回 子串起始字母的 正索引，没有找到返回-1。
				rfind(sub[, start[, end]]) -> int
					在[start,end) 区间内， 从右至查找子串sub。找到返回 子串起始字母的 正索引，没有找到返回-1。		

					In [210]: s = "I am very very very sorry"

					In [211]: s.find('very')
					Out[211]: 5

					In [212]: s.find('very',5)
					Out[212]: 5

					In [213]: s.find('very',6)
					Out[213]: 10

					In [214]: s.find('very',11)
					Out[214]: 15

					In [204]: s.find('y')
					Out[204]: 8

					In [205]: s.rfind('y')
					Out[205]: 24

					In [206]: len(s)
					Out[206]: 25

					In [207]: s.rfind('y',-1) #从-1那个位置找y。而不是-1到左侧起始  
					Out[207]: 24

					In [239]: s.rfind('very', -1) #从-1到起始的very是15, 只有-1那个位置是找不到very的.
					Out[239]: -1


					In [208]: s.rfind('y',-15,-1) #在[-10, -1)范围内，“very very sorr”从右向左查找y
					Out[208]: 18

					In [225]: s.rfind('very',-15, -1)  #在[-10, -1)范围内，“very very sorr”从右向左查找 very子串首个字母的索引。
					Out[225]: 15

					In [220]: s.rfind('y',20, -1) #从[20, -1)范围内，从右向左查找y， 不存在返回-1
					Out[220]: -1

					In [223]: s.find('xxxx',20) #不存在返回-1
					Out[223]: -1

				index(sub[, start[, end]]) -> int
					在[start,end) 区间内， 从左而右查找子串sub。找到返回 子串起始字母的 正索引，没有找到抛出异常IndexError。
				rindex(sub[, start[, end]]) -> int
					在[start,end) 区间内， 从右至查找子串sub。找到返回 子串起始字母的 正索引，没有找到抛出异常IndexError。

					In [226]: s = "I am very very very sorry"

					In [227]: s.index('very')
					Out[227]: 5

					In [228]: s.index('very', 5) #[5, 结束]
					Out[228]: 5

					In [229]: s.index('very', 6, 13) #[6,13)中找不到，抛出异常。
					---------------------------------------------------------------------------
					ValueError                                Traceback (most recent call last)
					<ipython-input-229-fe342f207469> in <module>()
					----> 1 s.index('very', 6, 13)

					ValueError: substring not found

					In [232]: s.rindex('very', 10) #[10,结束]中 very very sorry 从右向左找到very子串的首字母v，是15
					Out[232]: 15

					In [233]: s.rindex('very', 10, 15) #[10,15)中 very 从右向左找到very子串的首字母v，是10
					Out[233]: 10

					In [234]: s.rindex('very', -10, -1) #[-10,-1)中 very sorr 从右向左找到very子串的首字母v，是15
					Out[234]: 15

				时间复杂度:
					index, count方法都是O(n), 随着数据规模增大, 而效率下降

					len(string)返回字符串的长度, 即字符的个数. O(1)		


				count(sub[, start[, end]]) -> int
					在[start,end) 区间内, 从左而右, 统计子串sub出现的次数. 在给定范围内不存在此子串, 返回0. 

					In [244]: s
					Out[244]: 'I am very very very sorry'

					In [245]: s.count('very')
					Out[245]: 3

					In [246]: s.count('very', 10)
					Out[246]: 2

					In [247]: s.count('very', -10,-1)
					Out[247]: 1

					In [248]: s.count('very', -1)
					Out[248]: 0

			字符串判断*
				应用: 先strip掉,两台不想要的字符,再判断!!!
				endswith(suffix[, start[, end]]) -> bool
					在[start, end)区间内, 字符串是否suffix结尾.

				startswith(prefix[, start[, end]]) -> bool
					在[start, end)区间内, 字符串是否suffix开头.

					In [249]:  s
					Out[249]: 'I am very very very sorry'

					In [250]: s.startswith('very')
					Out[250]: False

					In [251]: s.startswith('very', 5)
					Out[251]: True

					In [252]: s.startswith('very', 5,9) #在[5,9)区间 very
					Out[252]: True

					In [253]: s.endswith('very', 5,9) 
					Out[253]: True

					In [254]: s.endswith('very', 5,10) #在[5,10) 'very '
					Out[254]: False

					In [255]: s.endswith('sorry') 
					Out[255]: True

					In [256]: s.endswith('sorry',5) #very very very sorry
					Out[256]: True

					In [257]: s.endswith('sorry',5, -1) #very very very sorr
					Out[257]: False

					In [258]: s.endswith('sorry',5, 100) #超界时, 当尾部.
					Out[258]: True

			字符串判断is系列
				isalnum() -> bool是否是字母和数字的组合, 浮点数不行.
				isalpha() -> bool是否是纯字母
				isdecimal() -> bool是否是纯十进制数字
				isdigit() 是否全数字
				isidentifier() 是否是字母和下划线开头，其它是字母、数字、下划线。****标识符定义一致？, 用户名
				islower() 是否全小写
				isupper() 是否全大写
				isspace() 是否只包含空白字符。 strip() 一下，如果全空白，只剩下空字符串。

			字符串格式化
				输出字符串：
					join：连接序列(sequence)中的元素。
					+：需要str()转换为字符串。

				python 2.5之前, c风格的printf函数 printf-style formatting
						%[-|补][width]<s|d|%|f> % (,)
							-： 开启左对齐，默认右对齐。
							补：当右对齐时，在左侧补0或空格。默认空格。
							width: 宽度，默认是后面字符长度。如果指定的宽度小于后面字符长度，则使用默认。反之，补充由"补"指定的字符。
							%s: str()
							%d: 整型数值
							%%: %本身
							%x: 小写十六进制
							%X: 大写十六进制

							%[[[补]宽度].精度]f: 浮点数
								%<.精度>f
								%<宽度><.精度>f
								%<补><宽度><.精度>f
								宽度：精度换算后的宽度

					格式要求
						占位符：占一个位置，以后将用数值来填充。%加一个格式字符组成。%s：后面数据当string处理.str(), %d转换为整型
						占位符中可以插入修饰字符：%03d: 3宽度，表示后面的字符占据3个位置。0表示为空的填充0.
						format % values, 格式字符串 分隔符% 被格式值
						values：只能是一个对象；%s % 5。 或和格式字符串占位符数目相等的元组或字典： %s %s % (5, 5)。且对象能被前面占位符转换

					In [269]: "I am %03d" % (20,) #20占3个宽度，空一个补0
					Out[269]: 'I am 020'

					In [270]: "I am %013d" % (20,)
					Out[270]: 'I am 0000000000020'

					In [271]: "I am %013d" % (20,21) #右边对象数目要与占位符数目一致！
					---------------------------------------------------------------------------
					TypeError                                 Traceback (most recent call last)
					<ipython-input-271-26d7cf56d769> in <module>()
					----> 1 "I am %013d" % (20,21)

					TypeError: not all arguments converted during string formatting

					In [272]: "I am %013d %10s" % (20,21) #前后一致时，20占3个宽度补0. 21占10个宽度，默认补空格。
					Out[272]: 'I am 0000000000020         21'

					In [273]: "I am %013d % 10s" % (20,21) #前后一致时，20占3个宽度补0. 21占10个宽度，补空格。
					Out[273]: 'I am 0000000000020         21'

					In [274]: "I am %013d % 10s %s" % (20,21) #前后数目不一致，会报异常。
					---------------------------------------------------------------------------
					TypeError                                 Traceback (most recent call last)
					<ipython-input-274-498ae5b23447> in <module>()
					----> 1 "I am %013d % 10s %s" % (20,21)

					TypeError: not enough arguments for format string

					# 打印本身
					In [287]: 'I am %s%%.' %  20
					Out[287]: 'I am 20%.'

					# 3是宽度.2精度，会四舍五入。%%: %. 10的16进制. X: 15的大写十六进制。F。占位符是0.
					In [288]: '%3.2f%%, Ox%x, OX%02X' % (89.7654, 10, 15)
					Out[288]: '89.77%, Oxa, OX0F'

					In [289]: '%3.2f%%, Ox%x, OX%02x' % (89.7654, 10, 15)
					Out[289]: '89.77%, Oxa, OX0f'

					#89.77是5个数字宽度
					In [293]: '%5.2f%%, Ox%x, OX%02x' % (89.7654, 10, 15)
					Out[293]: '89.77%, Oxa, OX0f'

					#前面是宽度，默认补空格.
					In [294]: '%6.2f%%, Ox%x, OX%02x' % (89.7654, 10, 15)
					Out[294]: ' 89.77%, Oxa, OX0f'

					#前面是宽度，补0.
					In [295]: '%06.2f%%, Ox%x, OX%02x' % (89.7654, 10, 15)
					Out[295]: '089.77%, Oxa, OX0f'

					#左对齐
					In [305]: '%6.2f%%, Ox%x, OX%02x' % (89.7654, 10, 15) #默认右对齐
					Out[305]: ' 89.77%, Oxa, OX0f'

					In [306]: '%-6.2f%%, Ox%x, OX%02x' % (89.7654, 10, 15) #加-表示左对齐
					Out[306]: '89.77 %, Oxa, OX0f'

					In [312]: '%-06.2f%%, Ox%x, OX%02x' % (89.7654, 10, 15) #使用左对齐时，补0或空格将失效
					Out[312]: '89.77 %, Oxa, OX0f'

				format函数 格式字符串语法 -------- Python鼓励使用

					"{} {xxx}".format(*args, **kwargs) -> str
						{} 占位符, 
							{} 表示按照顺序匹配位置参数. 0, 1, 2 ...
							{n} 将取后面序列的 由{}内指定的n索引 对应元素
							{xxx} 将取关键字参数中搜索名称一致的值
							{{}} 表示打印花括号
						{xxx} 占位符带名称,后面使用字典类型. 但是现在不使用字典类型. 所以后面**kwargs不需要使用了.
						*args: 位置参数,元组或列表
						kwargs: 关键字形参数, 一个字典

						字符串拼接和format都会new出一个新的字符串。

					位置参数,跟后面序列的索引相关
						In [313]: '{}:{}'.format('192.168.1.100', 8888) #按照索引顺序用位置参数替换 前面格式字符串中的占位符.
						Out[313]: '192.168.1.100:8888'
					关键字参数或命名参数, 按照名词匹配
						In [314]: "{server} {1}:{0}".format(8888, '192.168.1.100', server='Web Server Info: ') #根据格式字符串的占位符中的索引或key, 查找位置参数或关键字参数, 取得值.
						Out[314]: 'Web Server Info:  192.168.1.100:8888'
					访问元素: 只要索引或key对应的值能被str()转换, 都可以.
						In [315]: "{0[0]}.{0[1]}".format(('magedu', 'com'))
						Out[315]: 'magedu.com'

						#取序列中的第几个元素
						In [316]: t = ['magedu', 'com']

						In [317]: "{}.{}".format(t[0], t[1])
						Out[317]: 'magedu.com'

						In [319]: "{0}.{0}".format(('magedu', 'com')[0])
						Out[319]: 'magedu.magedu'

						In [321]: "{}.{}".format(('magedu', 'com')[0], ('', 'com')[1])
						Out[321]: 'magedu.com'

						In [322]: "{}".format([1, 2]) #索引0对应的列表,能被str()转换, 没有问题
						Out[322]: '[1, 2]'

						In [323]: "{}".format([1, 2, [3, 4], 5])
						Out[323]: '[1, 2, [3, 4], 5]'
					对象属性访问
						In [326]: from collections import namedtuple

						In [327]: Point = namedtuple('P', 'x y')

						In [328]: p1 = Point(5,6)

						In [329]: p1.x
						Out[329]: 5

						In [330]: p1.y
						Out[330]: 6

						#
						In [332]: p1
						Out[332]: P(x=5, y=6)

						In [333]: "{{{0}, {0}}}".format(p1) #将对象作为0
						Out[333]: '{P(x=5, y=6), P(x=5, y=6)}'

						In [334]: "Point = ({{{0.x}, {0.y}}})".format(p1) # 日志格式化, 便于切割、分析。
						Out[334]: 'Point = ({5, 6})'
					对齐
						{[index]:[补1][<|>][补2][width]}
							index：索引
							: 固定格式
							补1: 特殊字符, 左对齐，右侧补；右对齐，左侧补；居中两边补。
							[<|>] < 左对齐，>右对齐, 默认右对齐。 ^居中，先填充右边。
							补2：0或空格，默认补空格。左对齐，右侧补；右对侧，左侧补；居中两边补。
							width: 索引或key对应，位置参数或关键字参数中对应的元素，占用宽度。默认是字符长度。给定宽度小于值长度，默认。给定宽度大于值长度，补充 由补2指定的

							In [336]: '{0}*{1}={2:<2}'.format(3,2,2*3)# 格式字符串中索引2对应位置参数6，6占用两个字符宽度，默认补空格。左对齐，则右侧补空格。
							Out[336]: '3*2=6 '

							In [337]: '{0}*{1}={2:<02}'.format(3,2,2*3)# 给定补0。左对齐，则右侧补0。
							Out[337]: '3*2=60'

							In [342]: '{0}*{1}={2:>02}'.format(3,2,2*3)# 给定补0。右对齐，则左侧补0。
							Out[342]: '3*2=06'

							#居中
							In [347]: '{:^8}'.format('centered')
							Out[347]: 'centered'

							In [348]: '{:^9}'.format('centered')
							Out[348]: 'centered '

							In [349]: '{:^10}'.format('centered')
							Out[349]: ' centered '

							In [376]: '{:^30}'.format('centered')
							Out[376]: '           centered           '

							In [377]: '{:^030}'.format('centered') #居中两边补
							Out[377]: '00000000000centered00000000000'

							In [378]: '{:^#30}'.format('centered') #补2位置只能补0
							---------------------------------------------------------------------------
							ValueError                                Traceback (most recent call last)
							<ipython-input-378-d1c1dd612494> in <module>()
							----> 1 '{:^#30}'.format('centered')

							ValueError: Alternate form (#) not allowed in string format specifier

							In [379]: '{:0^30}'.format('centered') #补1位置可以补0或特殊字符。
							Out[379]: '00000000000centered00000000000'

							In [380]: '{:#^30}'.format('centered')
							Out[380]: '###########centered###########'

					进制
						{:d} 十进制
						{:x} 十六进制，加修饰符 {:#x}
						{:o} 八进制，加修饰符 {:#o}
						{:b} 二进制，加修饰符 {:#b}

						#无修饰符
						In [388]:  "int: {0:d}; hex: {0:x}; oct: {0:o}; bin: {0:b}".format(10)
						Out[388]: 'int: 10; hex: a; oct: 12; bin: 1010'

						#有修饰符
						In [400]:  "int: {0:d}; hex: {0:#x}; oct: {0:#o}; bin: {0:#b}".format(10)
						Out[400]: 'int: 10; hex: 0xa; oct: 0o12; bin: 0b1010'


						#大写进制
						In [405]: octets = [192, 168, 0, 1]

						In [406]: '{:02X}{:02X}{:02X}{:02X}'.format(*octets) # 参数解构，依次将每个元素分解开，4个元素，正好对应前面没有写的索引0，1，2，3
						Out[406]: 'C0A80001'

						In [407]: '{:02X} {:02X} {:02X} {:02X}'.format(*octets) #0和1的十六进制始终是0和1，占2个宽度，默认右对齐，所以左侧补0.
						Out[407]: 'C0 A8 00 01'

						In [408]: '{:02X} {:02X} {:02X} {:<02X}'.format(*octets) #修改为左对齐时，右侧补了0.
						Out[408]: 'C0 A8 00 10'

						扩展：参数解构
							octets = [192, 168, 0, 1] #4个元素
							(*octets)  #将分解成4个元素


					format练习
						语句块间故意留白
						好的习惯，变量先定义，显示了作用域
						用户输入一个数字
							判断是几位数
							打印每一位数及其重复的次数。打印顺序个、十、百、千、万...位打印

						输入5个数字，打印每个数字的位数，将三个数字排序打印，要求升序打印。

			bytes、bytearray
				python3引入两个新类型
					bytes     不可变 字节序列(字节在内存中就是连在一起的)。
					bytearray 可变 字节数组、列表

					字节序列和字符序列的差异
						字符串：按字符为单位组成的序列，可以编码来理解。
						字节：  按单个字节为单位组成的序列。可能只能半个字符。

					不可变序列变成可变序列：list()处理

				编码与解码
					编码：数字和字符对应关系。字符对应屏幕上的点阵。
					字符串按照不同的字符集编码encode返回字节序列bytes.
						encode(encoding='utf-8', errors='strict') -> bytes
							encoding：默认utf-8以什么编码方式
							errors: 默认为strict, 表示严格
							-> bytes: python3.5后，表示方法返回类型。
							字符 --> 数字

					解码：
					字节序列按照不同的字符集解码decode返回字符串.
						bytes.decode(encoding='utf-8', errors='strict') -> str
						bytesarray.decode(encoding='utf-8', errors='strict') -> str
							数字 --> 字符

					乱码：别人给出的方式，和你理解的方式不同。

				bytes		
					bytes定义
						bytes() 空bytes

						bytes(int) 由int指定bytes的长度, 补0填充
						bytes(iterable_of_ints) -> bytes  [0, 255]范围内的int组成的可迭代对象, 返回长度的bytes.

							In [501]: bytes(1)
							Out[501]: b'\x00'

							In [502]: bytes(2)
							Out[502]: b'\x00\x00'

							In [426]: bytes(range(10))
							Out[426]: b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t'

							In [427]: bytes(range(1))
							Out[427]: b'\x00'

							In [428]: bytes(range(100))
							Out[428]: b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f\x1
							12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !"#$%&\'()*+,-./01
							9:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abc'

							In [429]: bytes([1,3,5])
							Out[429]: b'\x01\x03\x05'

							In [430]: bytes([91,93,95])
							Out[430]: b'[]_'	
						bytes(string, encoding[, errors]) -> bytes 等价于string.encode()
							In [432]: bytes("abc",'utf-8')
							Out[432]: b'abc'

							In [433]: bytes("abc",'utf8')
							Out[433]: b'abc'

							In [434]: "abc".encode() #string.encode()示例
							Out[434]: b'abc' #字节序列

							In [435]: a = "abc".encode() #bytes.decode()示例

							In [436]: type(a)
							Out[436]: bytes

							In [437]: a.decode()
							Out[437]: 'abc' #字符

						bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer 从一个字节序列或buffer复制出一个新的不可变的bytes对象。 shadow拷贝。拷贝对象时，只是拷贝引用。
							In [449]: a
							Out[449]: b'abc'

							In [438]: b  =  bytes(a)
		 					#拷贝之后，内存地址不变，在列表中只是复杂类型、对象拷贝才只拷贝地址。这里就只拷贝了地址。但是拷贝出的结果是不可变的。列表拷贝出的结果是可变的。
							In [439]: id(a)
							Out[439]: 61909136

							In [440]: id(b)
							Out[440]: 61909136

							In [450]: a == b #拿两个bytes比较其中的abc
							Out[450]: True

							In [451]: a is b #比较id
							Out[451]: True

						使用b前缀
							b'abc' b' ', ' '里面是字节序列
							只允许基本ASCII使用字符形式b'abc9'
							使用16进制表示b"\x41\x61"

					bytes操作
						与string类型基本一致，都是不可变类型。注意，输入为bytes，输出也是bytes类型。
							In [472]: a
							Out[472]: b'abc'

							In [473]: a.split('b')
							---------------------------------------------------------------------------
							TypeError                                 Traceback (most recent call last)
							<ipython-input-473-3d4470876faa> in <module>()
							----> 1 a.split('b')

							TypeError: a bytes-like object is required, not 'str'

							In [474]: a.split(b'b')
							Out[474]: [b'a', b'c']

						类方法：bytes.fromhex(string)  string是两个字符的16进制形式, '6162 6a 6b', 空格将被忽略, 返回bytes.
							对象方法:
								a.split(b'b')
									a: 是bytes类的一个实例/对象。.split是对象方法。

							类方法: 拿类型找某个方法，即类方法。类似于c++, java中的静态方法。
								In [481]: str.
								         str.capitalize   str.encode       str.format       str.isalpha
								         str.casefold     str.endswith     str.format_map   str.isdecimal
								         str.center       str.expandtabs   str.index        str.isdigit      >
								         str.count        str.find         str.isalnum      str.isidentifier

							示例:
								In [484]: bytes.fromhex('6162 09 6a 6b00')
								Out[484]: b'ab\tjk\x00'

						hex() 返回16进制表示的字符串.
							'abc'.encode().hex()

						索引: bytes是不可变的字节序列, 可以索引可迭代.
							In [489]: b'abc'[2] # 返回该字节对应的数, int类型.
							Out[489]: 99

				bytearray()
					bytearray定义
						bytearray() 空bytearray
						bytearray(int) 由int指定bytearray的长度, 补0填充
						bytearray(iterable_of_ints) -> bytearray [0, 255]的int组成的可迭代对象
						bytearray(string, encoding[, errors]) -> bytearray 相似于string.encode(), 返回可变对象.
						bytearray(bytes_or_buffer) -> 从一个字节序列或buffer(bytearray)复制出一个新的可变的bytearray对象。 shadow拷贝。拷贝对象时，只是拷贝引用。
						注意: 使用b前缀定义的是bytes类型, 没有其它方式指定bytearray.

							#开空间
							In [512]: bytearray()
							Out[512]: bytearray(b'')

							In [513]: bytearray(1)
							Out[513]: bytearray(b'\x00')

							In [514]: bytearray(2)
							Out[514]: bytearray(b'\x00\x00')

							In [515]: bytearray(range(1))
							Out[515]: bytearray(b'\x00')

							In [516]: bytearray(range(2))
							Out[516]: bytearray(b'\x00\x01')

							#复制bytearray
							In [519]: a = bytearray('abc','utf-8')

							In [520]: a
							Out[520]: bytearray(b'abc')

							In [521]: b = bytearray(a)

							In [522]: id(a)
							Out[522]: 63096992

							In [523]: id(b)
							Out[523]: 63097536

							#复制bytes
							In [526]: a
							Out[526]: b'abc'

							In [527]: bytearray(a)
							Out[527]: bytearray(b'abc')

							可以转成列表,但是内存空间 list可能比bytearray占用多

					bytearray操作
						和bytes类型方法相同
							replace
							split
							find

						bytearray.fromhex(string)返回bytearray
						返回16进制字符串: bytearray('abc'.encode()).hex()

						索引: bytearray(b'abcdef')[2] 返回该字节对应的数, int类型. [0, 255]

					bytearray额外操作: 就地修改
						append(int) 追加
						insert(index, int) 在指定位置插入元素
						extend(iterable_of_ints) 将一个可迭代序列追加	到当前bytearray

						pop(index=-1) 

						remove(value) 找到第一个value移除, 找不到抛出异常ValuError

						注意, 上述方法若需要使用int类型时,[0, 255]

						clear() 清空bytearray

						reverse() 翻转bytearray, 就地修改

							In [528]: b = bytearray()

							In [529]: b.append(97)

							In [530]: b.append(99)

							In [531]: b
							Out[531]: bytearray(b'ac')

							In [532]: b.insert(1,98)

							In [533]: b
							Out[533]: bytearray(b'abc')

							In [534]: b.extend([65, 66, 67])

							In [535]: b
							Out[535]: bytearray(b'abcABC')

							In [536]: b.remove(66)

							In [537]: b
							Out[537]: bytearray(b'abcAC')

							In [538]: b.pop()
							Out[538]: 67

							In [539]: b
							Out[539]: bytearray(b'abcA')

							In [540]: b.reverse()

							In [541]: b
							Out[541]: bytearray(b'Acba')

							In [542]: b.clear()

							In [543]: b
							Out[543]: bytearray(b'')


		2）列表: 由若干个元素(数值、字符、对象、列表)有序的组成
			元素可变的线性数据结构
				元素是对象：是指针。复制的是指针。修改复制后的结果会影响原列表。
				元素是数值、字符：是具体的数。复制的具体的数。修改复制后的结果不会影响原列表。
			符号：[]

			list、链表、queue、stack差异
				list：内存中排序整齐，由前一个知道下一个在哪。固定偏移。
				链表：内存中零散的放着，不能使用索引。
				queue: 可列表或链表实现，队伍特点：先进先出(放行)或后进先出(死胡同)。
				stack: 后进先出(死胡同)
				图形理解区别，然后用好它。

			1）、查帮助：
				1）开始菜单--> python3.x --> python manual --> 官方帮助文档 --> 搜索关键字

				2）Ipython中
					help(keyword)
						keyword: 变量名、对象名、类名、函数名、方法名，不是名时，会隐式转换成类名。

				3）Google

			2）、获取帮助：help(list)
				list() -> new empty list
				list(iterable) -> new list initialized from iterable's items
					iterable: 可迭代对象(range(), 顺序的也是可迭代的: 列表、字符串)

			3）、生成列表：
				lists = []
				lists = [1, 2, 'a', None, [1, 2, 'a', None]] #放不同的类型
					注意：lists列表中有5个元素，最后一个列表是一个整体元素。此处存放的是一个指针并非是列表，指针指向一个列表。

				lists = list()
				lists = list(range(5))

				lists = [i for i in range(5)]

			4）、索引访问元素：
				约定索引：
					左(下)边界 <---------------> 右(上)边界
					0 1 2 ........................ -3 -2 -1

				lists[index]
				索引超界(使用索引不能定位到列表中的元素)，引发异常IndexError.
				索引指向一段内存空间的起始地址。

				list[5] 是序号的第5+1个元素。
					序号：1, 2, 3, 4, 5 ...
					索引：0, 1, 2, 3, 4 ...

			1、列表操作：
				1）、查询
					1）单个元素的索引 index()
						index(value, [start[, stop]])
						在[start,stop)索引区间中，查找首个value时，返回value的索引(始终是正索引)。找不到值时，返回ValueError。

						>>> lst = [1, 2, 3, 2, 2, 5]
						>>> lst.index(2)
						1
						>>> lst.index(2,1)
						1
						>>> lst.index(2,2)
						3
						>>> lst.index(2,-1)
						Traceback (most recent call last):
						  File "<stdin>", line 1, in <module>
						ValueError: 2 is not in list
						>>> lst.index(2,-1,-4)
						Traceback (most recent call last):
						  File "<stdin>", line 1, in <module>
						ValueError: 2 is not in list
						>>> lst.index(2,-4,-1)
						3
					2）单个元素的次数 count()
						count(value)
						列表中值的个数
						>>> lst.count(2)
						3

					时间复杂度：
						O(1) 只需看一个元素，就能返回结果。
						O(n) 需要遍历所有元素，才能返回结果。n（列表元素）增加时，时间会一直向上增加。
						O(logn)
						O(n^2)
						
						注意：自己写的代码的效率问题。
					
					3）所有元素的个数 len()
						len(sequence)
						读的内存结构中固定的位置，专用于记录列表长度，是列表的元数据。
						自己设计数据结构，也需要将反复使用的数据放在一个固定的位置。

						>>> len('123')
						3
						>>> len(lists)
						5

				2）、修改：
					注意：列表长度不变。
					1）单个元素修改
						list[index]=value

						>>> lst = [1, 2, 3, 2, 2, 5, 2]	
						#最后一个元素
						>>> lst[len(lst)-1] = 6
						>>> lst
						[1, 2, 3, 2, 2, 5, 6]

					2）多个元素修改
						reversed() -> None

							列表的元素反转，返回None。除了中间那个不动(奇数个)，都要反转。
							就地修改

							>>> lst1
							[12, 13, 7, 1, 3, 2, 2, 5, 6, 10]
							>>> lst1.reverse()
							>>> lst1
							[10, 6, 5, 2, 2, 3, 1, 7, 13, 12]

						sort(key=None, reverse=False) -> None
							key=None, reverse=False： 表示缺省值，默认值。不用给：默认升序，由小到大。
							列表的元素排序
							就地修改
							>>> lst1
							[10, 6, 5, 2, 2, 3, 1, 7, 13, 12]
							>>> lst1.sort()
							>>> lst1
							[1, 2, 2, 3, 5, 6, 7, 10, 12, 13]

							注意：对存在默认值的函数，第一个参数必须是默认值。进行传参时，只对非默认值的参数赋值时，应该写上参数名等于值。否则会将实参与行参一一对应，这样就给行参第一个赋值了。
							>>> lst1.sort(True)
							Traceback (most recent call last):
							  File "<stdin>", line 1, in <module>
							TypeError: must use keyword argument for key function

							>>> lst1.sort(reverse=True)
							>>> lst1
							[13, 12, 10, 7, 6, 5, 3, 2, 2, 1]

							注意：少用排序，需要输出有排序的序列的时候，在用sort.

							注意：相同类型排序没有问题，不同类型排序。使用函数: lst.sort(key=function)
							>>> lst1
							[13, 12, 10, 7, 6, 5, 3, 2, 2, 1]
							>>> lst1.append('a')
							>>> lst1
							[13, 12, 10, 7, 6, 5, 3, 2, 2, 1, 'a']
							>>> lst1.sort()
							Traceback (most recent call last):
							  File "<stdin>", line 1, in <module>
							TypeError: '<' not supported between instances of 'str' and 'int'
							#混合排序
							>>> lst1.sort(key=str) #使用str函数。相当于str()函数操作每个元素的结果进行排序。函数里面的参数是函数，是高阶函数。
							>>> lst1
							[1, 10, 12, 13, 2, 2, 3, 5, 6, 7, 'a']

							>>> lst1.sort(key=str, reverse=True) #看出降序效果。
							>>> lst1
							['a', 7, 6, 5, 3, 2, 2, 13, 12, 10, 1]

				3）、增加、插入元素：
					注意：列表长度改变
					append(object) -> None
						
						表示尾部追加一个元素返回空值(None)，返回空值(None)则表示就地修改(修改对象本身)。
						时间复杂度O(1)

						查看返回值为空值(None).
							>>> lst
							[1, 2, 3, 2, 2, 5, 6]
							>>> a = lst.append(10)
							>>> type(a)
							<class 'NoneType'>
							>>> a
							>>> print(a)
							None

					insert(index, object) -> None

						表示插队，会影响别人，所有元素都会向后挪(内存中所有元素会挪动)，效率极低。
							>>> lists
							[11, 0, 1, 2, 3, 4]
							>>> lists.insert(-1,11)
							>>> lists
							[11, 0, 1, 2, 3, 11, 4]
							>>> lists.insert(-2,12)
							>>> lists
							[11, 0, 1, 2, 3, 12, 11, 4]
						index超上界，上界追加。
						index超下界，下界插入。
							>>> lst
							[1, 2, 3, 2, 2, 5, 6, 10]
							>>> lst.insert(100,7) #调用append就可以了。
							>>> lst
							[1, 2, 3, 2, 2, 5, 6, 10, 7]

							>>> lst.insert(-100,7) #所有元素都会挪动，效率低。
							>>> lst
							[7, 1, 2, 3, 2, 2, 5, 6, 10, 7]

					*
						>>> lst1
						[]
						>>> lst1*5
						[]
						>>> lst1 = [1]
						>>> lst1*5 #有输出时，都不会变
						[1, 1, 1, 1, 1]
						>>> lst1 = lst1*5

					+ 
						>>> lst1 = [11, 12, 13]
						>>> lst
						[7, 1, 2, 3, 2, 2, 5, 6, 10, 7]
						>>> lst + lst1 #有输出时，都不会变
						[7, 1, 2, 3, 2, 2, 5, 6, 10, 7, 11, 12, 13]

					extend(iterable) -> None
						iterable: 可迭代对象(range(), 顺序的也是可迭代的: 列表)
						返回空值(None)则表示就地修改(修改对象本身)。
						>>> lst1 = [11, 12, 13]
						>>> lst
						[7, 1, 2, 3, 2, 2, 5, 6, 10, 7]
						>>> lst1.extend(lst1) #就地修改
						>>> lst1
						[11, 12, 13, 7, 1, 2, 3, 2, 2, 5, 6, 10, 7]

				4）、删除
					clear() -> None
						
						清空所有元素，剩下空列表。
						注意：很多对象释放(大规模的数据集清除后或做过多的clear)，会引起垃圾回收。这个时候你正在忙，它在垃圾回收。你的内存会被它调整一次。这个时候就带来效率问题。
							
						>>> lst
						[7, 1, 2, 3, 2, 2, 5, 6, 10, 7, 11, 12, 13]
						>>> lst.clear()
						>>> lst # 注意，剩下空列表
						[]

						扩展：
							clear() 和 = []区别
								list.clear() 内存结构保留，只清元素。
								list = []   内存结构清除。

					remove(value) -> None

						从左而右查找第一个匹配的value值，移除之。
						就地修改
						效率：中间操作会引起位置向前挪动，效率变低。	
						
						>>> lst1
						[11, 12, 13, 7, 1, 2, 3, 2, 2, 5, 6, 10, 7]
						>>> lst1.remove(2)
						>>> lst1
						[11, 12, 13, 7, 1, 3, 2, 2, 5, 6, 10, 7]

					pop([index]) -> item
						注意：返回不是None，也是就地修改。
						pop() 移除最后一个元素，返回此元素。 O(1)
						pop(index) 移除由index指定的元素，返回此元素。

							>>> lst1
							[11, 12, 13, 7, 1, 3, 2, 2, 5, 6, 10, 7]
							>>> lst1.pop()
							7
							>>> lst1
							[11, 12, 13, 7, 1, 3, 2, 2, 5, 6, 10]

							注意：当index为0时，列表足够长时，内存中整个列表的元素都会向前挪。效率极低！
								index不是-1时，效率都会有影响。
							>>> lst1
							[11, 12, 13, 7, 1, 3, 2, 2, 5, 6, 10]
							>>> lst1.pop(0)
							11
							>>> lst1
							[12, 13, 7, 1, 3, 2, 2, 5, 6, 10]


				5）、成员运算符: 是否是集合内的整个元素，返回布尔型。
					30 in [[30,20]] False
					[3, 4] in [1, 2, [3, 4]] True
					for x in [1, 2, 3, 4] 循环

					布尔型可以放在if语句中
						if 30 not in [[30, 20]]:
							pass #pass是占位语句，什么都不做。不pass，语法不对。怎么处理不知道。回过头来修改。

			2、列表复制

				小知识：
					== 值比较
					is 比内存地址，id()值比较。

					>>> lst0 = list(range(4))
					>>> id(lst0) #id() 获取标识，内存地址。
					45913072
					>>> hash(lst0) #列表不可hash
					Traceback (most recent call last):
					  File "<stdin>", line 1, in <module>
					TypeError: unhashable type: 'list'
					>>> hash(id(lst0)) #整型hash是本身
					45913072
					>>> lst1 = list(range(4))
					>>> id(lst1)
					45936688
					>>> lst0 == lst1  #== 比较内容
					True	
					>>> lst0 is lst1  #is 比较内容和内存位置. not is
					False
					
				注意：= 赋值	
					变量名：对内存中一段空间起名。 
					>>> lst1 = lst0
					>>> id(lst1) #此处内存地址是上面lst0内存地址，相同的。
					45913072

					lst1[2] = 10
					>>> lst1
					[0, 1, 10, 3]
					>>> lst0 #注意，修改lst1也把lst0修改了。
					[0, 1, 10, 3]


				copy() -> list
					
					拷贝出一个新列表。
					>>> lst0 = list(range(4))
					>>> lst0
					[0, 1, 2, 3]
					>>> lst0.copy()
					[0, 1, 2, 3]
					>>> lst5 = lst0.copy() #浅拷贝
					>>> lst5
					[0, 1, 2, 3]
					>>> lst0 == lst5
					True
					>>> id(lst0)
					45827056
					>>> id(lst5)
					45905040
					>>> lst5 is lst0
					False

					注意：列表元素是复杂类型(列表、对象...)，拷贝的是复杂类型的地址。
					>>> lst0 = [1, [2, 3, 4], 5]
					>>> lst5 = lst0.copy()
					>>> lst0
					[1, [2, 3, 4], 5]
					>>> lst5
					[1, [2, 3, 4], 5]
					>>> lst5 == lst0
					True
					>>> lst5 is lst0
					False

					#对于非复杂类型单个元素拷贝的是本身。
					>>> lst5[2] = 10
					>>> lst5
					[1, [2, 3, 4], 10]
					>>> lst0
					[1, [2, 3, 4], 5]
					>>>
					#对于复杂类型(列表、对象...)，拷贝的是地址
					>>> lst5[2] = 5
					>>> lst5
					[1, [2, 3, 4], 5]
					>>> lst0
					[1, [2, 3, 4], 5]
					
						#一个列表复杂类型中的元素改变，另一个列表复杂类型中的元素也改变了。
						>>> lst5[1][1] = 20
						>>> lst5 == lst0
						True
						>>> lst5
						[1, [2, 20, 4], 5]
						>>> lst0
						[1, [2, 20, 4], 5]


				扩展：不仅仅是复制，追加一个复杂类型也是引用的追加
					>>> row = []
					>>> lists = [2]
					>>> lists.append(row)
					>>> lists
					[2, []]
					>>> row.append('abc')
					>>> lists
					[2, ['abc']]


				扩展：深拷贝
					和以上浅拷贝的区别在于：拷贝元素是复杂类型时，拷贝的是整个元素，拷贝源和拷贝出的内容复杂类型是指向不同位置。浅拷贝只拷贝引用，拷贝源和拷贝出的内容复杂类型是指向相同位置。
					>>> import copy
					>>> lst0 = [1, [2, 3, 4], 5]
					>>> lst5 = copy.deepcopy(lst0) #深拷贝
					>>> lst5[1][1] = 20
					>>> lst5
					[1, [2, 20, 4], 5]
					>>> lst0
					[1, [2, 3, 4], 5]
					一般情况下，只用浅拷贝就可以了。

				赋值和copy()区别
					赋值：内存地址相同
					copy() 复杂类型引用地址相同

				copy() 和copy.deepcopy()区别
					copy() 复杂类型引用地址相同
					copy.deepcopy() 复杂类型引用地址不同，但是内容相同。

			3、随机数
				#依赖此模块
				import random

				1）、随机取区间内的整数
						

					>>> import random
					>>> random.randint(0,1)
					0
					>>> random.randint(0,1)
					1
				
				2）、随机取序列中的元素
					random.choice(sequence)
					
					>>> random.choice('abc')
					'b'
					>>> random.choice(['a',1,2])
					2
					>>> random.choice(range(10))
					5	

				3）、随机从range()函数内取单个整数。
					random.randrange()
						
						randrange(stop) -> 从0到stop-1之间取任意单个整数
						randrange(start, stop[, step]) -> [start, stop) 范围取消单个整数


					>>> random.randrange(1)
					0
					>>> random.randrange(2)
					0
					>>> random.randrange(2)
					1

				4) 、将列表元素打乱
					random.shuffle(list) -> None

					>>> lst.sort()
					>>> lst
					[1, 2, 3, 4, 5]
					>>> random.shuffle(lst) #洗列表
					>>> lst
					[1, 5, 2, 4, 3]

					>>> lst.append('a')
					>>> lst
					[1, 5, 2, 4, 3, 'a']
					>>> lst.sort(key=str)
					>>> lst
					[1, 2, 3, 4, 5, 'a']
					>>> random.shuffle(lst)  #洗列表
					>>> lst
					['a', 5, 1, 2, 3, 4]
					>>>

			列表练习
				1、100以内所有素数，一个数能被素数整除就是合数。将算过的质数保留下来。
					合数：2-(本身-1)是否能被整除
					合数：能被素数整除
				2、求杨辉三角
					1）
					2）加0
					3）
						开辟列表空间：列表解析式、循环迭代
						能不能少算一半数字
						
		3）tuple, 相当于只读列表
			元素不可变的有序的序列
			()表示
			注意: 内容不可变, 但是属性可以改变

			结构简单,比列表占用更少的内存空间

			1、定义元组
				tuple() -> 空元组
				tuple(iterable) -> 可迭代对象构造tuple

				空元组
					t = tuple()
					t = ()
				多个元素
					t = tuple(range(1,7,2)) # iterable
					t = (2,4,5,6,2) #可重复
				单个元素
					t = (1,)
					t = (1,)*5
					t = (1,2,3)*6

					In [1]: t1 = (1,) # 单个元素必须加,

					In [2]: type(t1)
					Out[2]: tuple

					In [3]: t1 = (1) # 单个元素没有逗号, 则表示为优先级.

					In [4]: type(t1)
					Out[4]: int

			有序和无序
				有序: 添加进去的顺序和打印出来的顺序相同
				无序: 添加进去的顺序和打印出来的顺序不相同

			2、常用函数
				index(value, [start,[stop]]) 求索引
				count(value) 数数	
				len(tuple)   个数

				元组只读， 没有增、改、删除操作

			3、特殊修改元组
				In [23]: t1
				Out[23]: (1, [2, 3], 4) #里面的列表对象，只是存储了一个引用。

				In [24]: t1[0] = 10
				---------------------------------------------------------------------------
				TypeError                                 Traceback (most recent call last)
				<ipython-input-24-49727f6c8925> in <module>()
				----> 1 t1[0] = 10

				TypeError: 'tuple' object does not support item assignment

				In [25]: t1[1][0] = 10 # 只修改了引用指向对象，并没有修改引用。

				In [26]: t1
				Out[26]: (1, [10, 3], 4)

			4、命名元组namedtuple, 搜索官方文档的关键字
				collections.namedtuple(typename, field_names, *, verbose=False, rename=False, module=None) 
					命名元组，返回一个元组的子类， 并定义了字段
					typename  类型名
					field_names可以是空格或逗号分割的字段的字符串，可以是字段的列表。
					verbose=False, rename=False, module=None 带等号，表示默认值

					from collections import namedtuple
					# 从集合大类的集合下面导入某个类namedtuple
				列表
					In [29]: Point = namedtuple('_Point	', ['x','y']) #Point, field_names即定义类的属性

					In []: type(Point)
					Out[]: type

					In [30]: p = Point(11,22) #从类实例出对象

					In [44]: p
					Out[44]: _Point(x=11, y=22)

					In [45]: p.x
					Out[45]: 11

					In [46]: p.y
					Out[46]: 22

					In [48]: p.x + p.y
					Out[48]: 33

				空格
					In [36]:  Student = namedtuple('_Student', 'name age')

					In [37]: tom = Student('tom', 20)

					In [40]: jerry = Student('jerry', 18)

					In [41]: jerry.name
					Out[41]: 'jerry'

					In [42]: jerry.age
					Out[42]: 18

			练习：
				1、3个数, if-else语句实现由小至大
				a = 1
				b = 2
				c = 1
				
				if a >= b or a >= c:
					if b >= c:
						print(a, b, c)
					else:
						print(a, c, b)
				if b >= a or b >= c:
					print(b, c, a) if c >= a else print(b, a, c)
				if c >= a or c >= b:
					print(c, a, b) if a >= b else print(c, b, a)
				2、3个数, max函数
					lst = []
					lst.append(a)
					lst.append(b)
					lst.append(c)

					while lst:
						max_n = max(lst)
						lst.remove(max_n)
						print(max_n)
				3、sort
					lst = []
					lst.append(a)
					lst.append(b)
					lst.append(c)

					lst.sort(reverse=False)

				4、冒泡法
					lst = []
					lst.append(a)
					lst.append(b)
					lst.append(c)

					for i in range(len(lst)):
						for j in range(i,len(lst)):
							if lst[i] > lst[i+1]:
								tmp = lst[i+1]
								lst[i+1] = lst[i]
								lst[i] = tmp

		线性结构(sequence)
			for .. in
			len() 获取长度, 是元数据.
			通过下标可以访问, 可索引
			可切片
			
			可迭代的一定可迭代,未必是线性结构.
			线性结构一定是可迭代的.

		学过的线性结构
			list, tuple, string, bytes, bytearray

		切片
			从给定seqence, 取出片段 
			sequece[start:stop], 表示返回[start, stop)区间的子序列

				start始终在stop左边
				    -3 -2 -1 0 1 2 3

				In [553]: 'www.magedu.com'[4:10] [4,10)
				Out[553]: 'magedu'

				In [554]: 'www.magedu.com'[:10] 起始到10)
				Out[554]: 'www.magedu'

				In [555]: 'www.magedu.com'[4:] [4,结束
				Out[555]: 'magedu.com'

				In [556]: 'www.magedu.com'[:] #从头取到尾, 返回一个新的字符串, 相当浅拷贝, copy()
				Out[556]: 'www.magedu.com' # 有返回,表示新生成的.

				In [557]: 'www.magedu.com'[:-1] #不包括结束的一位.
				Out[557]: 'www.magedu.co'

				In [558]: 'www.magedu.com'[4:-4]
				Out[558]: 'magedu'

				In [558]: 'www.magedu.com'[4:4] [4,4)取不到返回空
				Out[558]: ''

				In [559]: 'www.magedu.com'[4:50]
				Out[559]: 'magedu.com'

				In [561]: b'www.magedu.com'[-40:10] #不可变bytes
				Out[561]: b'www.magedu'

				In [562]: bytearray(b'www.magedu.com')[-4:10] #start落在stop右边, 匹配不到返回空, 复制bytes为bytearray.
				Out[562]: bytearray(b'')

				In [564]: tuple('www.magedu.com')[-10:10]
				Out[564]: ('m', 'a', 'g', 'e', 'd', 'u')

				In [565]: list('www.magedu.com')[-10:-4]
				Out[565]: ['m', 'a', 'g', 'e', 'd', 'u']

			步长切片
				[start:stop:step]
					step: 步长, 分正负. 默认是1.
						1: ----> 正向坐标系, 取的字符串,  是正方向.
						-1: <--- 反向坐标系, 取的字符串, 是反方向.

					step要和start:stop同向, 否则返回空序列. 
 					
				 In [565]: list('www.magedu.com')[-10:-4]
				Out[565]: ['m', 'a', 'g', 'e', 'd', 'u']

				In [566]:

				In [566]: list('www.magedu.com')[-10:-4:1]
				Out[566]: ['m', 'a', 'g', 'e', 'd', 'u']

				In [567]: list('www.magedu.com')[-10:-4:-1]
				Out[567]: []

				In [568]: list('www.magedu.com')[-4:-10]
				Out[568]: []

				In [569]: list('www.magedu.com')[-4:-10:-1] #反向
				Out[569]: ['.', 'u', 'd', 'e', 'g', 'a']
		
	三、键值对
		集合: 
			约定
				set 翻译为集合（老师叫集）
				collection翻译为集合类型，是一个大概念

			set
				在内存中是散放着
				可变的、无序的、不重复的元素的集合
					可变: bytearray, list
					无序：认识是无序的，不可索引，其实是有序的。可以迭代。
					不重复：集合最大用处，去重
			set定义，初始化
				set()
				set(iterable)

				s = set()
				s = set(range(5))
				s = set(list(range(10)))
				s = set(tuple(range(10)))
				s = set(enumerate(range(10)))
				s = {} #dict, 空的，留给字典。没有元素只能 set()
				s = {1} #set
				s = {9,10,11} #set
				s = {(1,2),3,'a',None,b'abc'} 
				s = {[1],(1,),1} #注意其中不能放list, 不可hash类型。不可变类型才可hash. 可变的[1], bytearray(b'a')不能作为元素。

			set接的iterable中的元素
				必须可以hash, hash()测试

					hash([1])
					hash('abc')
					hash(b'abc')
				s = {['abc',b'abc']}
				s = set(s)
				s = set(list(s))
				目前学过的不可hash类型有list, bytearray(b'xxx')

				无序，不可以索引
				set可以迭代

			se增加
				add('elem')
					增加一个元素到set中
					s.add(1)
					s.add(2)
				update(*others)

					s.update([1,3,2])
					s.update([1,3,2],{2,3,4})	#合并多个集合到
		字典: dict




